<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Application Performance &amp; JVM Hot Spot Tuning | Home Pages</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Application Performance &amp; JVM Hot Spot Tuning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="      Aspects of Slow Performing Applications   Application Level Problems   Multi-Threading/Deadlock Issues   Transactional/Synchronizations Issues   Memory Allocation/Management Issues   Bad Application Architecture   Un-Suitable OR Less Capable Framework Selection   Under or Over Estimated Application Capacity or Load   Bad Coding Issues   No Better or Suitable Use of Cache, No SQL DB   Bad Query Writing (If Applicable)   Infrastructural Level Problems   Application Layers/Tiers Bottlenecks   IO Calls/Resources Bottlenecks (Application, Cache, DB)   Underperformed or Already Heavily Loaded Physical Servers (Application, Cache, DB)   Not Properly Tuned Physical Servers for OS, DB, Cache, JVM/Tomcat   Infrastructural Bottlenecks (Firewalls, VPNs, Security Layers, Network Channel)   Mis-Calculated Failover or Scalability Strategy           Aspects To Consider For Great Performing Applications   Application Level Considerations   Concurrency Aspects [To Be Taken Care, During Design &amp; Implementation]: Following are important aspects of a distributed, multi-tier, concurrent &amp; multi- threaded applications, which needed to be taken care care of during design &amp; implementation:       Smooth &amp; Concurrent Application Logging       Graceful Exception/Error Handling especially Deadlocks       Graceful Transaction Handling considering ACID Approach (Either Optimistic or Pessimistic Locking)       Parallel &amp; Sequential Request Handling Capability       Usage of Thread Safe &amp; Concurrent Data Structures &amp; Collections       Adapting &amp; Utilizing Design Patterns e.g. GoF or SOLID       Using Code Review Tools e.g. Sonar, FindBug, PMD       Adapting &amp; Utilizing Performance Best Practices During Design &amp; Coding       Code Reviews w.r.t Performance       Regression / Load / Performance Testing       Application Performance Management &amp; Review w.r.t Load &amp; Volume using Regression Testing       Application Performance Benchmarking using Performance Testing       Identification of Resources OR Memory Leaking using Profiling Tools       Optimise Use of Cache &amp; DB       DBMS Tuning (Proper Clustered &amp; Non-Clustered Indexes &amp; Choice of Rights Indexes w.r.t Load and Data Type)       Optimized SQL Query Writing (If Applicable), Reviewed Query Execution Plans w.r.t Indexes       Use of Cache OR No SQL DB for Static or Long Lived Data Objects               Infrastructural Level Considerations   Scalability Strategy:   Horizontal (Application Nodes)       Vertical (Application Tiers/Layers)       Failover &amp; High Availability Strategy:   Application Level (Parallel Nodes)   Application Server Level (e.g. Tomcat)   Server Level (e.g. Physical Machine)   Data Center Level (e.g. Data Center A)   Region Level e.g. (e.g. EU, US, LAC, AP, CEMEA)   Data Management   Data Volume Forecasting w.r.t DB Nodes &amp; Disk Space Required (Monthly, Quarterly and Yearly)   Data Capacity Planning w.r.t Data Volume   Data Archiving &amp; Purging Strategy   DB Load Management, Database Failover &amp; Recovery Strategy   Multiple DB Nodes Handling Strategy &amp; e.g. Primary, Secondary, Tertiary   Syncing &amp; Real-time Backups of DB   Offline Database Backups Strategy       Non-Functional Considerations   Handling N Concurrent Requests/Users   Handling High Data Volume   Optimization and Performance   Multi-threading and Concurrency   Portability   High Availability   Vertical &amp; Horizontal Scalability   Security Benchmarking   Performance Benchmarking   Threat Modeling &amp; Vulnerability Scans   Continuous Integration   Multi Hardware, OS, JDK, DB, App Servers, Internet Browsers, Protocols &amp; Use Agents Support           Fine Tuned JVM for Better Garbage Collection and Application Performance   The Java Garbage Collector is referred to as a Generational Garbage Collector. Objects in an application live for varying lengths of time depending on where they are created and how they are used. The key insight here is that using different garbage collection strategies for short lived and long lived objects allows the GC to be optimised specifically for each case. Loosely speaking as objects “survive” repeated garbage collections in the Young Generation they are migrated to the Tenured Generation. The Permanent Generation is a special case, it contains objects that are needed by the JVM that are not necessarily represented in your program, for example objects that represent classes and methods.       Java Heap Memory is part of memory allocated to JVM by Operating System. Whenever we create objects they are created inside heap in java. Java Heap space is divided into three regions or generation for sake of garbage collection called Young Generation, Old or Tenured Generation and Permanent Generation.       The Young Generation is where all new objects are allocated and aged. When the young generation fills up, this causes a minor garbage collection. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.       The Old Generation is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called a major garbage collection.       The Permanent Generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. PermGen has been replaced with Metaspace since Java 8 release. PermSize &amp; MaxPermSize parameters will be ignored now.       Following are the factors which can affect the performance of JVM and in result performance of application:       Number of Iterations of Full/Major Garbage Collection   Uncontrolled &amp; Frequent Iterations of Minor Garbage Collection   Managing Heap Size and Stack Size / Thread Process Space   JIT Optimization   Selection of Appropriate GCs For Young &amp; Tenured Memory Space   Running JVM On Defaults w/o Understanding Nature of System   Scope of Tuning of System e.g. For Throughtput, Handling Short or Long Lived Objects, Batch Routines, Heavy Processing   Non-Heap GC   Although applications performance is mainly rely on, how it is developed and/or aptitude of programming and/or good programming practices. Surely tuning JVM will not solve problems related to bad programming or selection of inappropriate data structures. But with the help fine tuned JVM we can get better results w.r.t handling of unusual load and better throughput and memory management.       Proposed JVM Settings       -server -Xss4m -Xms4096m -Xmx4096m -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:+AggressiveOpts -XX:+DoEscapeAnalysis -Xnoclassgc -XX:+UseBiasedLocking -XX:ReservedCodeCacheSize=48m -XX:+UseCompressedOops   -XX:+UseStringDeduplication -XX:MaxGCPauseMillis=200 -XX:GCPauseIntervalMillis=4000       -XX:+AggressiveOpts: JVM performance optimisation, it enables some internal mechanism of JVM for better throughput and memory management       -XX:+UseBiasedLocking: Performance optimisation of locking mechanism specifically synchronization       -XX:+DoEscapeAnalysis: less GC activity and 14x faster execution of code       -XX:ReservedCodeCacheSize: JIT optimization       -XX:+UseStringDeduplication: https://blog.codecentric.de/en/2014/08/string-deduplication-new-feature-java-8-update-20-2/       -XX:+UseCompressedOops: When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB. This option works only for 64-bit JVMs.       As we are aware that all the GCs are “Stop The World”, even CMS and G1GC when there is need of Full/Major GC. But G1GC has special capability, that it’ll collect memory with minor garbage collection during normal transaction processing without being stoping any operations/thread within JVM. Because G1Gc supports Parallelism, Concurrency and Multi-Threading.       The purpose of these below JVM Params controlling Major GC:       -XX:MaxGCPauseMillis=200: The value of this param will pause/stop all threads for 200 Millis for Garbage Collection.       -XX:GCPauseIntervalMillis=4000: Using value of this params G1GC will look after 4 seconds to see if there is need of garbage collection or not.       Resources   Kindly have a look at these important resources for better understanding and getting idea about Garbage Collection.       http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html       http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html       http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html       http://javaproseeker.blogspot.jp/2014/08/anatomy-of-g1-garbage-first-collector.html" />
<meta property="og:description" content="      Aspects of Slow Performing Applications   Application Level Problems   Multi-Threading/Deadlock Issues   Transactional/Synchronizations Issues   Memory Allocation/Management Issues   Bad Application Architecture   Un-Suitable OR Less Capable Framework Selection   Under or Over Estimated Application Capacity or Load   Bad Coding Issues   No Better or Suitable Use of Cache, No SQL DB   Bad Query Writing (If Applicable)   Infrastructural Level Problems   Application Layers/Tiers Bottlenecks   IO Calls/Resources Bottlenecks (Application, Cache, DB)   Underperformed or Already Heavily Loaded Physical Servers (Application, Cache, DB)   Not Properly Tuned Physical Servers for OS, DB, Cache, JVM/Tomcat   Infrastructural Bottlenecks (Firewalls, VPNs, Security Layers, Network Channel)   Mis-Calculated Failover or Scalability Strategy           Aspects To Consider For Great Performing Applications   Application Level Considerations   Concurrency Aspects [To Be Taken Care, During Design &amp; Implementation]: Following are important aspects of a distributed, multi-tier, concurrent &amp; multi- threaded applications, which needed to be taken care care of during design &amp; implementation:       Smooth &amp; Concurrent Application Logging       Graceful Exception/Error Handling especially Deadlocks       Graceful Transaction Handling considering ACID Approach (Either Optimistic or Pessimistic Locking)       Parallel &amp; Sequential Request Handling Capability       Usage of Thread Safe &amp; Concurrent Data Structures &amp; Collections       Adapting &amp; Utilizing Design Patterns e.g. GoF or SOLID       Using Code Review Tools e.g. Sonar, FindBug, PMD       Adapting &amp; Utilizing Performance Best Practices During Design &amp; Coding       Code Reviews w.r.t Performance       Regression / Load / Performance Testing       Application Performance Management &amp; Review w.r.t Load &amp; Volume using Regression Testing       Application Performance Benchmarking using Performance Testing       Identification of Resources OR Memory Leaking using Profiling Tools       Optimise Use of Cache &amp; DB       DBMS Tuning (Proper Clustered &amp; Non-Clustered Indexes &amp; Choice of Rights Indexes w.r.t Load and Data Type)       Optimized SQL Query Writing (If Applicable), Reviewed Query Execution Plans w.r.t Indexes       Use of Cache OR No SQL DB for Static or Long Lived Data Objects               Infrastructural Level Considerations   Scalability Strategy:   Horizontal (Application Nodes)       Vertical (Application Tiers/Layers)       Failover &amp; High Availability Strategy:   Application Level (Parallel Nodes)   Application Server Level (e.g. Tomcat)   Server Level (e.g. Physical Machine)   Data Center Level (e.g. Data Center A)   Region Level e.g. (e.g. EU, US, LAC, AP, CEMEA)   Data Management   Data Volume Forecasting w.r.t DB Nodes &amp; Disk Space Required (Monthly, Quarterly and Yearly)   Data Capacity Planning w.r.t Data Volume   Data Archiving &amp; Purging Strategy   DB Load Management, Database Failover &amp; Recovery Strategy   Multiple DB Nodes Handling Strategy &amp; e.g. Primary, Secondary, Tertiary   Syncing &amp; Real-time Backups of DB   Offline Database Backups Strategy       Non-Functional Considerations   Handling N Concurrent Requests/Users   Handling High Data Volume   Optimization and Performance   Multi-threading and Concurrency   Portability   High Availability   Vertical &amp; Horizontal Scalability   Security Benchmarking   Performance Benchmarking   Threat Modeling &amp; Vulnerability Scans   Continuous Integration   Multi Hardware, OS, JDK, DB, App Servers, Internet Browsers, Protocols &amp; Use Agents Support           Fine Tuned JVM for Better Garbage Collection and Application Performance   The Java Garbage Collector is referred to as a Generational Garbage Collector. Objects in an application live for varying lengths of time depending on where they are created and how they are used. The key insight here is that using different garbage collection strategies for short lived and long lived objects allows the GC to be optimised specifically for each case. Loosely speaking as objects “survive” repeated garbage collections in the Young Generation they are migrated to the Tenured Generation. The Permanent Generation is a special case, it contains objects that are needed by the JVM that are not necessarily represented in your program, for example objects that represent classes and methods.       Java Heap Memory is part of memory allocated to JVM by Operating System. Whenever we create objects they are created inside heap in java. Java Heap space is divided into three regions or generation for sake of garbage collection called Young Generation, Old or Tenured Generation and Permanent Generation.       The Young Generation is where all new objects are allocated and aged. When the young generation fills up, this causes a minor garbage collection. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.       The Old Generation is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called a major garbage collection.       The Permanent Generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. PermGen has been replaced with Metaspace since Java 8 release. PermSize &amp; MaxPermSize parameters will be ignored now.       Following are the factors which can affect the performance of JVM and in result performance of application:       Number of Iterations of Full/Major Garbage Collection   Uncontrolled &amp; Frequent Iterations of Minor Garbage Collection   Managing Heap Size and Stack Size / Thread Process Space   JIT Optimization   Selection of Appropriate GCs For Young &amp; Tenured Memory Space   Running JVM On Defaults w/o Understanding Nature of System   Scope of Tuning of System e.g. For Throughtput, Handling Short or Long Lived Objects, Batch Routines, Heavy Processing   Non-Heap GC   Although applications performance is mainly rely on, how it is developed and/or aptitude of programming and/or good programming practices. Surely tuning JVM will not solve problems related to bad programming or selection of inappropriate data structures. But with the help fine tuned JVM we can get better results w.r.t handling of unusual load and better throughput and memory management.       Proposed JVM Settings       -server -Xss4m -Xms4096m -Xmx4096m -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:+AggressiveOpts -XX:+DoEscapeAnalysis -Xnoclassgc -XX:+UseBiasedLocking -XX:ReservedCodeCacheSize=48m -XX:+UseCompressedOops   -XX:+UseStringDeduplication -XX:MaxGCPauseMillis=200 -XX:GCPauseIntervalMillis=4000       -XX:+AggressiveOpts: JVM performance optimisation, it enables some internal mechanism of JVM for better throughput and memory management       -XX:+UseBiasedLocking: Performance optimisation of locking mechanism specifically synchronization       -XX:+DoEscapeAnalysis: less GC activity and 14x faster execution of code       -XX:ReservedCodeCacheSize: JIT optimization       -XX:+UseStringDeduplication: https://blog.codecentric.de/en/2014/08/string-deduplication-new-feature-java-8-update-20-2/       -XX:+UseCompressedOops: When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB. This option works only for 64-bit JVMs.       As we are aware that all the GCs are “Stop The World”, even CMS and G1GC when there is need of Full/Major GC. But G1GC has special capability, that it’ll collect memory with minor garbage collection during normal transaction processing without being stoping any operations/thread within JVM. Because G1Gc supports Parallelism, Concurrency and Multi-Threading.       The purpose of these below JVM Params controlling Major GC:       -XX:MaxGCPauseMillis=200: The value of this param will pause/stop all threads for 200 Millis for Garbage Collection.       -XX:GCPauseIntervalMillis=4000: Using value of this params G1GC will look after 4 seconds to see if there is need of garbage collection or not.       Resources   Kindly have a look at these important resources for better understanding and getting idea about Garbage Collection.       http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html       http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html       http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html       http://javaproseeker.blogspot.jp/2014/08/anatomy-of-g1-garbage-first-collector.html" />
<link rel="canonical" href="http://localhost:4000/2022/02/02/Application-Performance-and-JVM-Hot-Spot-Tuning.html" />
<meta property="og:url" content="http://localhost:4000/2022/02/02/Application-Performance-and-JVM-Hot-Spot-Tuning.html" />
<meta property="og:site_name" content="Home Pages" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-02T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Application Performance &amp; JVM Hot Spot Tuning" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-02T00:00:00-05:00","datePublished":"2022-02-02T00:00:00-05:00","description":"      Aspects of Slow Performing Applications   Application Level Problems   Multi-Threading/Deadlock Issues   Transactional/Synchronizations Issues   Memory Allocation/Management Issues   Bad Application Architecture   Un-Suitable OR Less Capable Framework Selection   Under or Over Estimated Application Capacity or Load   Bad Coding Issues   No Better or Suitable Use of Cache, No SQL DB   Bad Query Writing (If Applicable)   Infrastructural Level Problems   Application Layers/Tiers Bottlenecks   IO Calls/Resources Bottlenecks (Application, Cache, DB)   Underperformed or Already Heavily Loaded Physical Servers (Application, Cache, DB)   Not Properly Tuned Physical Servers for OS, DB, Cache, JVM/Tomcat   Infrastructural Bottlenecks (Firewalls, VPNs, Security Layers, Network Channel)   Mis-Calculated Failover or Scalability Strategy           Aspects To Consider For Great Performing Applications   Application Level Considerations   Concurrency Aspects [To Be Taken Care, During Design &amp; Implementation]: Following are important aspects of a distributed, multi-tier, concurrent &amp; multi- threaded applications, which needed to be taken care care of during design &amp; implementation:       Smooth &amp; Concurrent Application Logging       Graceful Exception/Error Handling especially Deadlocks       Graceful Transaction Handling considering ACID Approach (Either Optimistic or Pessimistic Locking)       Parallel &amp; Sequential Request Handling Capability       Usage of Thread Safe &amp; Concurrent Data Structures &amp; Collections       Adapting &amp; Utilizing Design Patterns e.g. GoF or SOLID       Using Code Review Tools e.g. Sonar, FindBug, PMD       Adapting &amp; Utilizing Performance Best Practices During Design &amp; Coding       Code Reviews w.r.t Performance       Regression / Load / Performance Testing       Application Performance Management &amp; Review w.r.t Load &amp; Volume using Regression Testing       Application Performance Benchmarking using Performance Testing       Identification of Resources OR Memory Leaking using Profiling Tools       Optimise Use of Cache &amp; DB       DBMS Tuning (Proper Clustered &amp; Non-Clustered Indexes &amp; Choice of Rights Indexes w.r.t Load and Data Type)       Optimized SQL Query Writing (If Applicable), Reviewed Query Execution Plans w.r.t Indexes       Use of Cache OR No SQL DB for Static or Long Lived Data Objects               Infrastructural Level Considerations   Scalability Strategy:   Horizontal (Application Nodes)       Vertical (Application Tiers/Layers)       Failover &amp; High Availability Strategy:   Application Level (Parallel Nodes)   Application Server Level (e.g. Tomcat)   Server Level (e.g. Physical Machine)   Data Center Level (e.g. Data Center A)   Region Level e.g. (e.g. EU, US, LAC, AP, CEMEA)   Data Management   Data Volume Forecasting w.r.t DB Nodes &amp; Disk Space Required (Monthly, Quarterly and Yearly)   Data Capacity Planning w.r.t Data Volume   Data Archiving &amp; Purging Strategy   DB Load Management, Database Failover &amp; Recovery Strategy   Multiple DB Nodes Handling Strategy &amp; e.g. Primary, Secondary, Tertiary   Syncing &amp; Real-time Backups of DB   Offline Database Backups Strategy       Non-Functional Considerations   Handling N Concurrent Requests/Users   Handling High Data Volume   Optimization and Performance   Multi-threading and Concurrency   Portability   High Availability   Vertical &amp; Horizontal Scalability   Security Benchmarking   Performance Benchmarking   Threat Modeling &amp; Vulnerability Scans   Continuous Integration   Multi Hardware, OS, JDK, DB, App Servers, Internet Browsers, Protocols &amp; Use Agents Support           Fine Tuned JVM for Better Garbage Collection and Application Performance   The Java Garbage Collector is referred to as a Generational Garbage Collector. Objects in an application live for varying lengths of time depending on where they are created and how they are used. The key insight here is that using different garbage collection strategies for short lived and long lived objects allows the GC to be optimised specifically for each case. Loosely speaking as objects “survive” repeated garbage collections in the Young Generation they are migrated to the Tenured Generation. The Permanent Generation is a special case, it contains objects that are needed by the JVM that are not necessarily represented in your program, for example objects that represent classes and methods.       Java Heap Memory is part of memory allocated to JVM by Operating System. Whenever we create objects they are created inside heap in java. Java Heap space is divided into three regions or generation for sake of garbage collection called Young Generation, Old or Tenured Generation and Permanent Generation.       The Young Generation is where all new objects are allocated and aged. When the young generation fills up, this causes a minor garbage collection. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.       The Old Generation is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called a major garbage collection.       The Permanent Generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. PermGen has been replaced with Metaspace since Java 8 release. PermSize &amp; MaxPermSize parameters will be ignored now.       Following are the factors which can affect the performance of JVM and in result performance of application:       Number of Iterations of Full/Major Garbage Collection   Uncontrolled &amp; Frequent Iterations of Minor Garbage Collection   Managing Heap Size and Stack Size / Thread Process Space   JIT Optimization   Selection of Appropriate GCs For Young &amp; Tenured Memory Space   Running JVM On Defaults w/o Understanding Nature of System   Scope of Tuning of System e.g. For Throughtput, Handling Short or Long Lived Objects, Batch Routines, Heavy Processing   Non-Heap GC   Although applications performance is mainly rely on, how it is developed and/or aptitude of programming and/or good programming practices. Surely tuning JVM will not solve problems related to bad programming or selection of inappropriate data structures. But with the help fine tuned JVM we can get better results w.r.t handling of unusual load and better throughput and memory management.       Proposed JVM Settings       -server -Xss4m -Xms4096m -Xmx4096m -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:+AggressiveOpts -XX:+DoEscapeAnalysis -Xnoclassgc -XX:+UseBiasedLocking -XX:ReservedCodeCacheSize=48m -XX:+UseCompressedOops   -XX:+UseStringDeduplication -XX:MaxGCPauseMillis=200 -XX:GCPauseIntervalMillis=4000       -XX:+AggressiveOpts: JVM performance optimisation, it enables some internal mechanism of JVM for better throughput and memory management       -XX:+UseBiasedLocking: Performance optimisation of locking mechanism specifically synchronization       -XX:+DoEscapeAnalysis: less GC activity and 14x faster execution of code       -XX:ReservedCodeCacheSize: JIT optimization       -XX:+UseStringDeduplication: https://blog.codecentric.de/en/2014/08/string-deduplication-new-feature-java-8-update-20-2/       -XX:+UseCompressedOops: When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB. This option works only for 64-bit JVMs.       As we are aware that all the GCs are “Stop The World”, even CMS and G1GC when there is need of Full/Major GC. But G1GC has special capability, that it’ll collect memory with minor garbage collection during normal transaction processing without being stoping any operations/thread within JVM. Because G1Gc supports Parallelism, Concurrency and Multi-Threading.       The purpose of these below JVM Params controlling Major GC:       -XX:MaxGCPauseMillis=200: The value of this param will pause/stop all threads for 200 Millis for Garbage Collection.       -XX:GCPauseIntervalMillis=4000: Using value of this params G1GC will look after 4 seconds to see if there is need of garbage collection or not.       Resources   Kindly have a look at these important resources for better understanding and getting idea about Garbage Collection.       http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html       http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html       http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html       http://javaproseeker.blogspot.jp/2014/08/anatomy-of-g1-garbage-first-collector.html","headline":"Application Performance &amp; JVM Hot Spot Tuning","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/02/02/Application-Performance-and-JVM-Hot-Spot-Tuning.html"},"url":"http://localhost:4000/2022/02/02/Application-Performance-and-JVM-Hot-Spot-Tuning.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Home Pages" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Home Pages</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/resume/">Resume</a><a class="page-link" href="/summary/">Summary</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Application Performance &amp; JVM Hot Spot Tuning</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-02-02T00:00:00-05:00" itemprop="datePublished">Feb 2, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <table>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Aspects of Slow Performing Applications</td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Level Problems</td>
    </tr>
    <tr>
      <td> </td>
      <td>Multi-Threading/Deadlock Issues</td>
    </tr>
    <tr>
      <td> </td>
      <td>Transactional/Synchronizations Issues</td>
    </tr>
    <tr>
      <td> </td>
      <td>Memory Allocation/Management Issues</td>
    </tr>
    <tr>
      <td> </td>
      <td>Bad Application Architecture</td>
    </tr>
    <tr>
      <td> </td>
      <td>Un-Suitable OR Less Capable Framework Selection</td>
    </tr>
    <tr>
      <td> </td>
      <td>Under or Over Estimated Application Capacity or Load</td>
    </tr>
    <tr>
      <td> </td>
      <td>Bad Coding Issues</td>
    </tr>
    <tr>
      <td> </td>
      <td>No Better or Suitable Use of Cache, No SQL DB</td>
    </tr>
    <tr>
      <td> </td>
      <td>Bad Query Writing (If Applicable)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Infrastructural Level Problems</td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Layers/Tiers Bottlenecks</td>
    </tr>
    <tr>
      <td> </td>
      <td>IO Calls/Resources Bottlenecks (Application, Cache, DB)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Underperformed or Already Heavily Loaded Physical Servers (Application, Cache, DB)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Not Properly Tuned Physical Servers for OS, DB, Cache, JVM/Tomcat</td>
    </tr>
    <tr>
      <td> </td>
      <td>Infrastructural Bottlenecks (Firewalls, VPNs, Security Layers, Network Channel)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Mis-Calculated Failover or Scalability Strategy</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Aspects To Consider For Great Performing Applications</td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Level Considerations</td>
    </tr>
    <tr>
      <td> </td>
      <td>Concurrency Aspects [To Be Taken Care, During Design &amp; Implementation]: Following are important aspects of a distributed, multi-tier, concurrent &amp; multi- threaded applications, which needed to be taken care care of during design &amp; implementation:</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Smooth &amp; Concurrent Application Logging</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Graceful Exception/Error Handling especially Deadlocks</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Graceful Transaction Handling considering ACID Approach (Either Optimistic or Pessimistic Locking)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Parallel &amp; Sequential Request Handling Capability</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Usage of Thread Safe &amp; Concurrent Data Structures &amp; Collections</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Adapting &amp; Utilizing Design Patterns e.g. GoF or SOLID</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Using Code Review Tools e.g. Sonar, FindBug, PMD</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Adapting &amp; Utilizing Performance Best Practices During Design &amp; Coding</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Code Reviews w.r.t Performance</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Regression / Load / Performance Testing</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Performance Management &amp; Review w.r.t Load &amp; Volume using Regression Testing</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Performance Benchmarking using Performance Testing</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Identification of Resources OR Memory Leaking using Profiling Tools</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Optimise Use of Cache &amp; DB</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>DBMS Tuning (Proper Clustered &amp; Non-Clustered Indexes &amp; Choice of Rights Indexes w.r.t Load and Data Type)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Optimized SQL Query Writing (If Applicable), Reviewed Query Execution Plans w.r.t Indexes</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Use of Cache OR No SQL DB for Static or Long Lived Data Objects</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Infrastructural Level Considerations</td>
    </tr>
    <tr>
      <td> </td>
      <td>Scalability Strategy:</td>
    </tr>
    <tr>
      <td> </td>
      <td>Horizontal (Application Nodes)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Vertical (Application Tiers/Layers)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Failover &amp; High Availability Strategy:</td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Level (Parallel Nodes)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Application Server Level (e.g. Tomcat)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Server Level (e.g. Physical Machine)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Data Center Level (e.g. Data Center A)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Region Level e.g. (e.g. EU, US, LAC, AP, CEMEA)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Data Management</td>
    </tr>
    <tr>
      <td> </td>
      <td>Data Volume Forecasting w.r.t DB Nodes &amp; Disk Space Required (Monthly, Quarterly and Yearly)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Data Capacity Planning w.r.t Data Volume</td>
    </tr>
    <tr>
      <td> </td>
      <td>Data Archiving &amp; Purging Strategy</td>
    </tr>
    <tr>
      <td> </td>
      <td>DB Load Management, Database Failover &amp; Recovery Strategy</td>
    </tr>
    <tr>
      <td> </td>
      <td>Multiple DB Nodes Handling Strategy &amp; e.g. Primary, Secondary, Tertiary</td>
    </tr>
    <tr>
      <td> </td>
      <td>Syncing &amp; Real-time Backups of DB</td>
    </tr>
    <tr>
      <td> </td>
      <td>Offline Database Backups Strategy</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Non-Functional Considerations</td>
    </tr>
    <tr>
      <td> </td>
      <td>Handling N Concurrent Requests/Users</td>
    </tr>
    <tr>
      <td> </td>
      <td>Handling High Data Volume</td>
    </tr>
    <tr>
      <td> </td>
      <td>Optimization and Performance</td>
    </tr>
    <tr>
      <td> </td>
      <td>Multi-threading and Concurrency</td>
    </tr>
    <tr>
      <td> </td>
      <td>Portability</td>
    </tr>
    <tr>
      <td> </td>
      <td>High Availability</td>
    </tr>
    <tr>
      <td> </td>
      <td>Vertical &amp; Horizontal Scalability</td>
    </tr>
    <tr>
      <td> </td>
      <td>Security Benchmarking</td>
    </tr>
    <tr>
      <td> </td>
      <td>Performance Benchmarking</td>
    </tr>
    <tr>
      <td> </td>
      <td>Threat Modeling &amp; Vulnerability Scans</td>
    </tr>
    <tr>
      <td> </td>
      <td>Continuous Integration</td>
    </tr>
    <tr>
      <td> </td>
      <td>Multi Hardware, OS, JDK, DB, App Servers, Internet Browsers, Protocols &amp; Use Agents Support</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Fine Tuned JVM for Better Garbage Collection and Application Performance</td>
    </tr>
    <tr>
      <td> </td>
      <td>The Java Garbage Collector is referred to as a Generational Garbage Collector. Objects in an application live for varying lengths of time depending on where they are created and how they are used. The key insight here is that using different garbage collection strategies for short lived and long lived objects allows the GC to be optimised specifically for each case. Loosely speaking as objects “survive” repeated garbage collections in the Young Generation they are migrated to the Tenured Generation. The Permanent Generation is a special case, it contains objects that are needed by the JVM that are not necessarily represented in your program, for example objects that represent classes and methods.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Java Heap Memory is part of memory allocated to JVM by Operating System. Whenever we create objects they are created inside heap in java. Java Heap space is divided into three regions or generation for sake of garbage collection called Young Generation, Old or Tenured Generation and Permanent Generation.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>The Young Generation is where all new objects are allocated and aged. When the young generation fills up, this causes a minor garbage collection. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>The Old Generation is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called a major garbage collection.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>The Permanent Generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. PermGen has been replaced with Metaspace since Java 8 release. PermSize &amp; MaxPermSize parameters will be ignored now.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td> </td>
      <td>Following are the factors which can affect the performance of JVM and in result performance of application:</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Number of Iterations of Full/Major Garbage Collection</td>
    </tr>
    <tr>
      <td> </td>
      <td>Uncontrolled &amp; Frequent Iterations of Minor Garbage Collection</td>
    </tr>
    <tr>
      <td> </td>
      <td>Managing Heap Size and Stack Size / Thread Process Space</td>
    </tr>
    <tr>
      <td> </td>
      <td>JIT Optimization</td>
    </tr>
    <tr>
      <td> </td>
      <td>Selection of Appropriate GCs For Young &amp; Tenured Memory Space</td>
    </tr>
    <tr>
      <td> </td>
      <td>Running JVM On Defaults w/o Understanding Nature of System</td>
    </tr>
    <tr>
      <td> </td>
      <td>Scope of Tuning of System e.g. For Throughtput, Handling Short or Long Lived Objects, Batch Routines, Heavy Processing</td>
    </tr>
    <tr>
      <td> </td>
      <td>Non-Heap GC</td>
    </tr>
    <tr>
      <td> </td>
      <td>Although applications performance is mainly rely on, how it is developed and/or aptitude of programming and/or good programming practices. Surely tuning JVM will not solve problems related to bad programming or selection of inappropriate data structures. But with the help fine tuned JVM we can get better results w.r.t handling of unusual load and better throughput and memory management.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Proposed JVM Settings</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-server -Xss4m -Xms4096m -Xmx4096m -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:+AggressiveOpts -XX:+DoEscapeAnalysis -Xnoclassgc -XX:+UseBiasedLocking -XX:ReservedCodeCacheSize=48m -XX:+UseCompressedOops</td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+UseStringDeduplication -XX:MaxGCPauseMillis=200 -XX:GCPauseIntervalMillis=4000</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+AggressiveOpts: JVM performance optimisation, it enables some internal mechanism of JVM for better throughput and memory management</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+UseBiasedLocking: Performance optimisation of locking mechanism specifically synchronization</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+DoEscapeAnalysis: less GC activity and 14x faster execution of code</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:ReservedCodeCacheSize: JIT optimization</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+UseStringDeduplication: https://blog.codecentric.de/en/2014/08/string-deduplication-new-feature-java-8-update-20-2/</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:+UseCompressedOops: When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB. This option works only for 64-bit JVMs.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>As we are aware that all the GCs are “Stop The World”, even CMS and G1GC when there is need of Full/Major GC. But G1GC has special capability, that it’ll collect memory with minor garbage collection during normal transaction processing without being stoping any operations/thread within JVM. Because G1Gc supports Parallelism, Concurrency and Multi-Threading.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>The purpose of these below JVM Params controlling Major GC:</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:MaxGCPauseMillis=200: The value of this param will pause/stop all threads for 200 Millis for Garbage Collection.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-XX:GCPauseIntervalMillis=4000: Using value of this params G1GC will look after 4 seconds to see if there is need of garbage collection or not.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>Resources</td>
    </tr>
    <tr>
      <td> </td>
      <td>Kindly have a look at these important resources for better understanding and getting idea about Garbage Collection.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>http://javaproseeker.blogspot.jp/2014/08/anatomy-of-g1-garbage-first-collector.html</td>
    </tr>
  </tbody>
</table>

  </div><a class="u-url" href="/2022/02/02/Application-Performance-and-JVM-Hot-Spot-Tuning.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Systems Design, Distributed Systems, ML</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
